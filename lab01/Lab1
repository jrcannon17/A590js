/*Filename: Lab1.js *
 *Part of: Lab1 A590js program *
 *Created by: Joshua Cannon *
 *Created on: 03/05/2019 *
 *Last Modified by: Joshua Cannon *
 *Last Modified on:
 */
console.log("    _\n ('v')\n (( ))\n-/-\"---\"--\n");
//return some chars with new lines

console.log(Infinity + 3);
// adds 3 to a string called infinity 
/*displays infinity*/

console.log( typeof Infinity );
// claims Infinite type
/*spits back number, which I suppose makes sense*/

console.log( typeof 4.5 );
//outputs float int
/*spat back a number? Does js not have int defs?*/

console.log( typeof 3 );
//outputs int type
/*spat back number, which is an unsigned int in my opinion*/

console.log( 3 / 0 );
// error message: correction, spits out Infinity which makes sense

console.log( -3 / 0 );
// error message: same as above command because of 0 denominator 

console.log( Infinity - Infinity );
//outputs 0
/*puts NaN. So if two infinities collide, there is no number I suppose*/

console.log( 0 / 0 );
// Infinity
/*really says no number.*/

console.log( typeof NaN );
// Not a number type
/*wasn't expecting this output. If NaN is not a number, why is it a number?*/

console.log( Math.random() < 0.5 ? "heads" : "tails" );
//outputs heads or tails by random chance set at 50 percent
/*This is apparant from previous program experience*/

console.log( typeof undefined );
// undefined 
/*correct*/

console.log( typeof null );
// outputs object: this is because Null defines an object

console.log(8 * null);
//outputs Null
/*0 is the answer. When combined with int operations, it acts as a 0. +5 will produce the number*/

console.log("5" - 1);
//outputs string -1 
/*treated a string as number in this case which was not expected. */

console.log("5" + 1);
//outputs string + 1
/*just concated 1 with 5 to make 51 is what it seems like to me. But the previous answer treated 5 as an int. It seems to auto default a string number to an int*/

console.log("couch" * 2);
//outputs two couches
/*produces NaN instead. This proves the above condition to be partially true in auto defaultation*/

console.log(false == 0);
//Produces True
/*FALSE and TRUE are normally set at this value in return*/

console.log(null == undefined);
//error?
/*I thought these two were different but now this explains a little bit better why the above output does what it does*/

console.log(null == 0);
//replaces FALSE? 
/*I thought it wouldn't, and I was correct. 0 is the default FALSE return value*/

console.log(undefined == 0);
//error because undefined already taken?
/*same as above. Produces false because TRUE is already taken as 1*/

console.log(null || "user");
// User is not null, it is a string
/*produces user because it is not Null*/

console.log("Karl" || "user");
//Karl is not a null user
/*not sure why it produces Karl*/

console.log(undefined || "tomato");
// tomato is not a defined value
/*produces tomato over undefined, because out of the two, it produces a type*/

console.log("tomato" &&"pasta");
//tomatato pasta concat 
/*produces last thing AND'd with*/
